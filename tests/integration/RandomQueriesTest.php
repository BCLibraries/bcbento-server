<?php

namespace App\Tests\integration;

use App\Testing\QueryBuilder;
use GraphQL\Client;
use PHPUnit\Framework\TestCase;

/**
 * Run a set of random queries against the server
 *
 *
 */
class RandomQueriesTest extends TestCase
{
    private const QUERY_STRING_FILE = __DIR__ . '/search-terms-hidden.csv';
    private const NUM_TOP_QUERIES_TO_TEST = 100;
    private const NUM_RANDOM_QUERIES_TO_TEST = 100;
    private const SECONDS_BETWEEN_QUERIES = 1;

    private Client $client;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->client = new Client('http://localhost:8000/graphql');
    }

    /**
     * Query a search term and make sure it doesn't fail or return gibberish
     *
     * @dataProvider queryProvider
     * @testdox Sent $type term "$term" successfully
     */
    public function testQueryDoesNotFail($term, $type)
    {
        $query = QueryBuilder::buildCatalogQuery($term);
        $result = $this->client->runQuery($query)->getData()->searchCatalog;
        sleep(self::SECONDS_BETWEEN_QUERIES);

        $possible_types = [
            'Archives',
            'Article',
            'Audio',
            'Book',
            'Collection',
            'Data',
            'Database',
            'Government document',
            'Image',
            'Journal',
            'Map',
            'Musical recording',
            'Newspaper article',
            'Reference entry',
            'Review',
            'Score',
            'Thesis',
            'Video',
            ''
        ];

        $this->assertNotEmpty($result->docs);

        foreach ($result->docs as $doc) {
            $this->assertIsString($doc->title);
            $this->assertObjectHasAttribute('creator', $doc);
            $this->assertIsArray($doc->contributors);
            $this->assertMatchesRegularExpression('/(bc_escholarship|ALMA-BC)/', $doc->linkableId);
            $this->assertIsString($doc->date);
            if (null !== $doc->mms) {
                $this->assertMatchesRegularExpression('/\d{16}/', $doc->mms);
            }
            $this->assertIsBool($doc->isPhysical);
            if ($doc->isPhysical) {
                $this->assertIsBool($doc->available);
            }
            $this->assertIsBool($doc->isElectronic);
            $this->assertContains($doc->type, $possible_types);

            if (isset($doc->availability)) {
                $this->assertIsString($doc->availability->libraryName);
                $this->assertIsString($doc->availability->locationName);
                $this->assertIsString($doc->availability->callNumber);
                $this->assertIsInt($doc->availability->totalCount);
                $this->assertIsBool($doc->availability->otherAvailabilities);
            }
        }
    }

    /**
     * Build a randomized array of search terms to test
     *
     * @return array
     */
    private function queryProvider(): array
    {
        $weighted_queries = [];
        $return_queries = [];

        // Open the CSV file and read the contents.
        if (($handle = fopen(self::QUERY_STRING_FILE, 'r')) !== FALSE) {
            fgetcsv($handle, 1000, ","); // Skip the header line
            $row = 0;
            while (($data = fgetcsv($handle, 1000, ",")) !== FALSE) {
                [$term, $weight] = $data;
                if ($row < self::NUM_TOP_QUERIES_TO_TEST) {
                    // $return_queries[] = [$term, 'popular'];
                } else {
                    $weighted_queries[$term] = $weight;
                }
                $row++;
            }
            fclose($handle);
        }

        // Build the array.
        for ($i = 0; $i <= self::NUM_RANDOM_QUERIES_TO_TEST; $i++) {

            // Choose a weighted random term and delete it from the set of available terms
            // so we don't load the same term twice.
            $term = $this->getRandomTerm($weighted_queries);
            unset($weighted_queries[$term]);
            $return_queries[] = [$term, 'random'];
        }

        return $return_queries;
    }

    /**
     * Get a random search term from the term list
     *
     * @param array $weighted_queries
     * @return int|string|void
     */
    private function getRandomTerm(array $weighted_queries)
    {

        // The term list is weighted so that more common terms are more likely to be
        // returned. Pick one.
        $total_weight = array_sum($weighted_queries);
        $random_value = mt_rand(0, $total_weight);
        foreach ($weighted_queries as $term => $weight) {
            $random_value -= $weight;
            if ($random_value <= 0) {
                return $term;
            }
        }
    }
}
